# Projet_LinuxEmbarque

Étudiants :
- Maria Luiza Costa Vianna
- Alexandre Houdeville
- Jalal Matar
- Louis Valery
- Anne-Laure Wozniak

Vous trouverez ci-dessous les sections suivantes :
- **Mise en place du système :** cette section explique comment nous avons installé et configuré les différents éléments de ce projet,
- **Documentation utilisateur :** cette section présente les étapes pour l'utilisation du projet.

## Mise en place du système

### Buildroot
Buildroot est un ensemble de Makefile permettant d'automatiser le processus de build d'une distribution Linux embarquée.

Dans le cadre de ce projet, une tarball Buildroot est disponible via une image Docker [ici](https://github.com/pblottiere/embsys/tree/master/labs/rpi3/docker), sous le nom "buildroot-video". La tarball contient le système d'exploitation précompilé qui sera embarqué sur la carte Raspberry Pi 3. Ce système supporte notamment la caméra que l'on souhaite manipuler. Afin de pouvoir interagir avec la caméra, on utilisera l'API [V4L](https://github.com/twam/v4l2grab).

On peut vérifier que tout est correctement configuré en s'assurant que les options `BR2_PACKAGE_RPI_FIRMWARE_X`  et `BR2_PACKAGE_LIBV4L` sont activées dans le fichier de configuration de Buildroot (fichier `/configs/embsys_defconfig`). Pour cela, il faudra cependant ouvrir au préalable un conteneur à l'aide de Docker et extraire la tarball.

### Docker
Pour accéder au système précompilé, on utilise Docker. Il s'agit d'un logiciel libre permettant la mise en oeuvre de conteneurs (environnements) de façon à isoler des applications (ici, notre système précompilé). Le kernel partage alors les ressources du système hôte et intéragit avec chacun des conteneurs en fonctionnement. Docker se distingue ainsi d'une machine virtuelle qui isole un système et dispose de ses propres ressources.

![IMG_Docker](https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-and-vm-transparent-bg.png)
source : https://www.docker.com/

Commandes :
```
$ sudo docker pull pblottiere/embsys-rpi3-buildroot-video
$ sudo docker run -it pblottiere/embsys-rpi3-buildroot-video /bin/bash
# cd /root
# tar zxvf buildroot-precompiled-2017.08.tar.gz
```
Concrètement, on récupère l'image Docker puis on crée un conteneur. Ensuite, on extrait le système.
On peut alors réaliser les vérifications sur les fichiers de configuration. Comme le système est précompilé, cela signifie que nous n'avons pas besoin de faire la configuration et le build à la main (`make embsys_defconfig`, `make menuconfig` et `make`). On peut passer directement au flashage.

### Flashage de la carte SD

Afin de flasher la carte SD qui sera insérée dans la Raspberry Pi 3, on doit tout d'abord créer une image :
```
$ docker cp <container_id>:/root/buildroot-precompiled-2017.08/output/images/sdcard.img .
```
On peut alors flasher la carte avec la commande :
```
$ sudo dd if=sdcard.img of=/dev/sdb
```
**NB.** Ici, la carte SD est considéré comme le second disque dur (nommé `/dev/sdb` par convention). Vérifier si c'est le cas sur votre machine avec la commande `lsblk`.

A l'issue de cette opération, la carte SD comporte normalement deux partitions.
On peut alors copier `start_x.elf` et `fixup_x.dat` depuis le conteneur sur la 1ère partition de la carte SD et modifier le fichier `config.txt` de la 1ère partition de la carte SD pour ajouter :
````
start_x=1
gpu_mem=128
````
La configuration et le flashage de la carte SD sont terminés.

### Configuration IP

Par la suite, nous aurons besoin de connaitre l'adresse IP de la carte afin de se connecter aux serveurs du servo-moteur et de la caméra.
Il peut arriver cependant que nous n'ayons pas accès à une IPv4 via la commande `ifconfig` mais à une IPv6. Il faut alors s'assurer que la carte et que la machine sur lequel est le client sont sur le même réseau. Dans notre cas, on a opté pour brancher directement la carte à l'ordinateur via un cable ethernet (RJ45). On suit alors les étapes suivantes :
- On fixe manuellement l'IP de l'ordinateur (dans la configuration du réseau directement). On a par exemple :
```
Address : 172.20.11.111
Netmask : 255.255.0.0
Gateway : 0.0.0.0 (optionnel)
```
- On fixe manuellement l'IP de la carte en modifiant le fichier `/etc/network/interfaces`:
```
# interface file auto-generated by buildroot

auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
  address 172.20.11.112
  netmask 255.255.0.0
  gateway 172.20.11.111
```

On peut vérifier que la configuration est la bonne en se connectant en ssh depuis l'ordinateur :
```
ssh user@172.20.11.112
```

### Configuration et installation de V4L

Comme évoqué précédement, V4L (Video4Linux) est une API vidéo pour les systèmes Linux. Il existe deux versions de cette API et on utilise ici la version 2 (V4L2). On pourra ainsi capturer les flux vidéo/image de la caméra de la RPI3.

Pour installer et configurer l'API sur la carte, on réalise les étapes suivantes :
- On récupère le projet v4l2grab :
```
$ git clone https://github.com/twam/v4l2grab
```
- Une fois dans le fichier v4l2grab, on peut activer les autotools :
```
$ sh autogen.sh
```
- On commente `#undef malloc` dans config.h.in

- On remplace `v4l2grab.c` avec un docker cp par celui qui est dans le ficher camera. Le but est de récuperer le code modifié par nous. 

- On compile pour la RPI3 :
```
$ ./configure CC=/root/buildroot-precompiled-2017.08/output/host/usr/bin/arm-linux-gcc --host=linux

$ make
```
Il s'agit ici de cross-compilation puisque la carte Raspberry n'a pas la même architecture que la machine sur laquelle on fait la compilation. Le binaire généré ne sera notamment pas exécutable sur ladite machine.

Une fois la compilation correctement terminée, on peut alors copier l'exécutable sur la carte RPI3 (dans le dossier `/root`). Les commandes suivantes permettent d'activer le module de la caméra et de prendre une photo :
```
$ modprobe bcm2835-v4l2
$ cd /root
$ ./v4l2grab -d /dev/video0 -o img.jpg
```

## Documentation utilisateur

### Contenu du dépôt Github

**Projet_LinuxEmbarque/camera :** codes en C et exécutable (après cross-compilation) pour l'API V4L2 et le serveur de la caméra associé.

**Projet_LinuxEmbarque/client_serveur_python :** codes du client et de deux serveurs en Python. Le client est celui utilisé sur la machine souhaitant communiquer avec la Raspberry, les deux serveurs ont servi pour les tests intermédiaires.

**Projet_LinuxEmbarque/servoMoteur :** code en Python pour la gestion du servomoteur et du serveur associé.

### Makefile

Un certain nombre de commandes peuvent être automatisées à l'aide d'un Makefile. On donne dans ce projet un exemple d'utilisation (qui peut sembler superflu, effectivement). On y a défini deux règles (`installation` et `client`), qui sont appelées par les commandes suivantes :
- `make installation` : Lorsque la carte SD est directement connectée à l'ordinateur, au moment du flashage par exemple, cette commande permet de copier le code Python pour le servo-moteur et l'exécutable pour le module V4L2 (permettant l'utilisation de la caméra et son serveur) au bon endroit sur la carte,
- `make client` : Lorsque l'on est connecté à la carte en ethernet, permet le lancement du client. Attention, cette commande ne doit être utilisée qu'une fois les serveurs lancés.

### Utilisation - Etapes

On part du principe que tout a été correctement configuré et que tous les fichiers nécessaires ont été copiées au bon endroit.

1. **Lancement serveurs :** Dans deux terminaux, se connecter en SSH (`ssh user@172.20.11.112`) puis passer superutilisateur (mot de passe `root1*`). Se placer dans le dossier `/root`et lancer les serveurs (`python serveur_sm.py` pour le servo-moteur et `./v4l2grab` pour la caméra).
2. **Lancement client :** Dans un nouveau terminal, lancer directement le client (`make client`). Il suffit alors de suivre les instructions du client pour communiquer avec les deux serveurs.

### Remarque

En l'état actuel, les images sont enregistrées dans le même répertoire que celui où se trouve le client, sur l'ordinateur. Néanmoins, les images sont envoyées avec un certains retard à l'ordinateur hébergeant le client:
- Lorsqu'on envoie "1 s" la première fois : le serveur crée l'image 0, mais ne l'envoie pas au client.
- Lorsqu'on envoie "1 s" la deuxième fois : le serveur crée l'image 1, mais ne l'envoie pas au client.
- Lorsqu'on envoie "1 s" la troisième fois : le serveur crée l'image 2, mais il envoie l'image 1 au client et elle est bien reçue et sauvegardée dans le répertoire du client.
- Lorsqu'on envoie "1 s" la quatrième fois : le serveur crée l'image 3, il envoie l'image 2 au client et elle est bien reçue et sauvegardée dans le répertoire du client et ainsi de suite...

Ainsi, seulement l'image 1 et la dernière image créée seront perdues, les autres vont arriver avec du retard sur l'ordinateur client. Pour le servomoteur tout fonctionne bien en direct.
